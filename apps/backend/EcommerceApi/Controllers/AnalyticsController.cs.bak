using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using EcommerceApi.Data;
using EcommerceApi.DTOs.Analytics;

namespace EcommerceApi.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AnalyticsController : ControllerBase
    {
        private readonly AppDbContext _context;
        private readonly ILogger<AnalyticsController> _logger;

        public AnalyticsController(AppDbContext context, ILogger<AnalyticsController> logger)
        {
            _context = context;
            _logger = logger;
        }

        // Helper to convert unspecified DateTime to UTC (needed for PostgreSQL timestamp with time zone)
        private DateTime? ToUtc(DateTime? dt)
        {
            if (!dt.HasValue) return null;
            if (dt.Value.Kind == DateTimeKind.Unspecified)
                return DateTime.SpecifyKind(dt.Value, DateTimeKind.Utc);
            return dt.Value.ToUniversalTime();
        }

        #region Revenue Analytics

        [HttpGet("revenue/summary")]
        [ProducesResponseType(typeof(RevenueSummaryDto), StatusCodes.Status200OK)]
        public async Task<ActionResult<RevenueSummaryDto>> GetRevenueSummary(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var query = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(o => o.CreatedAt <= toDate.Value);

                var orders = await query.ToListAsync();
                var payments = await _context.Payments
                    .Where(p => fromDate == null || p.CreatedAt >= fromDate.Value)
                    .Where(p => toDate == null || p.CreatedAt <= toDate.Value)
                    .ToListAsync();

                var totalRevenue = payments.Where(p => p.Status == "completed").Sum(p => p.Amount);
                var pendingRevenue = orders.Where(o => o.Status == "pending").Sum(o => o.TotalAmount);
                var completedRevenue = orders.Where(o => o.Status == "paid" || o.Status == "shipped" || o.Status == "delivered").Sum(o => o.TotalAmount);
                var refundedAmount = payments.Where(p => p.Status == "refunded").Sum(p => p.Amount);

                return Ok(new RevenueSummaryDto
                {
                    TotalRevenue = totalRevenue,
                    PendingRevenue = pendingRevenue,
                    CompletedRevenue = completedRevenue,
                    RefundedAmount = refundedAmount,
                    TotalOrders = orders.Count,
                    AverageOrderValue = orders.Count > 0 ? orders.Sum(o => o.TotalAmount) / orders.Count : 0
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving revenue summary");
                return StatusCode(500, new { message = "An error occurred while retrieving revenue summary" });
            }
        }

        [HttpGet("revenue/by-status")]
        [ProducesResponseType(typeof(List<RevenueBreakdownDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<RevenueBreakdownDto>>> GetRevenueByStatus(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                // Convert to UTC to avoid PostgreSQL timestamp issues
                fromDate = ToUtc(fromDate);
                toDate = ToUtc(toDate);
                var query = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(o => o.CreatedAt <= toDate.Value);

                var breakdown = await query
                    .GroupBy(o => o.Status)
                    .Select(g => new RevenueBreakdownDto
                    {
                        Category = g.Key,
                        CategoryType = "Status",
                        Revenue = g.Sum(o => o.TotalAmount),
                        OrderCount = g.Count(),
                        AverageOrderValue = g.Count() > 0 ? g.Sum(o => o.TotalAmount) / g.Count() : 0
                    })
                    .OrderByDescending(x => x.Revenue)
                    .ToListAsync();

                return Ok(breakdown);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving revenue by status");
                return StatusCode(500, new { message = "An error occurred while retrieving revenue by status" });
            }
        }

        [HttpGet("revenue/by-vendor")]
        [ProducesResponseType(typeof(List<RevenueBreakdownDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<RevenueBreakdownDto>>> GetRevenueByVendor(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var query = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(o => o.CreatedAt <= toDate.Value);

                var breakdown = await query
                    .SelectMany(o => o.Items)
                    .Include(oi => oi.Variant)
                    .ThenInclude(v => v.Product)
                    .GroupBy(oi => oi.Variant.Product.VendorId ?? Guid.Empty)
                    .Select(g => new
                    {
                        VendorId = g.Key,
                        VendorName = g.FirstOrDefault().Variant.Product.Vendor != null ? g.FirstOrDefault().Variant.Product.Vendor.Name : "Unknown",
                        Revenue = g.Sum(oi => oi.Price * oi.Quantity),
                        OrderCount = g.Select(oi => oi.OrderId).Distinct().Count(),
                        Items = g.Count()
                    })
                    .ToListAsync();

                var result = breakdown.Select(b => new RevenueBreakdownDto
                {
                    Category = b.VendorName,
                    CategoryType = "Vendor",
                    Revenue = b.Revenue,
                    OrderCount = b.OrderCount,
                    AverageOrderValue = b.OrderCount > 0 ? b.Revenue / b.OrderCount : 0
                })
                .OrderByDescending(x => x.Revenue)
                .ToList();

                return Ok(result);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving revenue by vendor");
                return StatusCode(500, new { message = "An error occurred while retrieving revenue by vendor" });
            }
        }

        [HttpGet("revenue/by-category")]
        [ProducesResponseType(typeof(List<RevenueBreakdownDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<RevenueBreakdownDto>>> GetRevenueByCategory(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var query = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(o => o.CreatedAt <= toDate.Value);

                var breakdown = await query
                    .SelectMany(o => o.Items)
                    .Include(oi => oi.Variant)
                    .ThenInclude(v => v.Product)
                    .ThenInclude(p => p.Category)
                    .GroupBy(oi => oi.Variant.Product.CategoryId)
                    .Select(g => new RevenueBreakdownDto
                    {
                        Category = g.FirstOrDefault().Variant.Product.Category.Name,
                        CategoryType = "Category",
                        Revenue = g.Sum(oi => oi.Price * oi.Quantity),
                        OrderCount = g.Select(oi => oi.OrderId).Distinct().Count(),
                        AverageOrderValue = g.Sum(oi => oi.Price * oi.Quantity) / g.Select(oi => oi.OrderId).Distinct().Count()
                    })
                    .OrderByDescending(x => x.Revenue)
                    .ToListAsync();

                return Ok(breakdown);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving revenue by category");
                return StatusCode(500, new { message = "An error occurred while retrieving revenue by category" });
            }
        }

        [HttpGet("revenue/by-payment-method")]
        [ProducesResponseType(typeof(List<RevenueBreakdownDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<RevenueBreakdownDto>>> GetRevenueByPaymentMethod(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var query = _context.Payments.Where(p => p.Status == "completed").AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(p => p.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(p => p.CreatedAt <= toDate.Value);

                var breakdown = await query
                    .GroupBy(p => p.Method)
                    .Select(g => new RevenueBreakdownDto
                    {
                        Category = g.Key,
                        CategoryType = "PaymentMethod",
                        Revenue = g.Sum(p => p.Amount),
                        OrderCount = g.Select(p => p.OrderId).Distinct().Count(),
                        AverageOrderValue = g.Count() > 0 ? g.Sum(p => p.Amount) / g.Count() : 0
                    })
                    .OrderByDescending(x => x.Revenue)
                    .ToListAsync();

                return Ok(breakdown);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving revenue by payment method");
                return StatusCode(500, new { message = "An error occurred while retrieving revenue by payment method" });
            }
        }

        [HttpGet("revenue/trends")]
        [ProducesResponseType(typeof(List<RevenueTrendDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<RevenueTrendDto>>> GetRevenueTrends(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate,
            [FromQuery] string period = "daily") // daily, weekly, monthly
        {
            try
            {
                var query = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(o => o.CreatedAt <= toDate.Value);

                var orders = await query.ToListAsync();

                List<RevenueTrendDto> trends;

                if (period.ToLower() == "daily")
                {
                    trends = orders
                        .GroupBy(o => o.CreatedAt.Date)
                        .Select(g => new RevenueTrendDto
                        {
                            Date = g.Key,
                            Revenue = g.Sum(o => o.TotalAmount),
                            OrderCount = g.Count(),
                            AverageOrderValue = g.Count() > 0 ? g.Sum(o => o.TotalAmount) / g.Count() : 0
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }
                else if (period.ToLower() == "weekly")
                {
                    trends = orders
                        .GroupBy(o => GetWeekStart(o.CreatedAt))
                        .Select(g => new RevenueTrendDto
                        {
                            Date = g.Key,
                            Revenue = g.Sum(o => o.TotalAmount),
                            OrderCount = g.Count(),
                            AverageOrderValue = g.Count() > 0 ? g.Sum(o => o.TotalAmount) / g.Count() : 0
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }
                else // monthly
                {
                    trends = orders
                        .GroupBy(o => new DateTime(o.CreatedAt.Year, o.CreatedAt.Month, 1))
                        .Select(g => new RevenueTrendDto
                        {
                            Date = g.Key,
                            Revenue = g.Sum(o => o.TotalAmount),
                            OrderCount = g.Count(),
                            AverageOrderValue = g.Count() > 0 ? g.Sum(o => o.TotalAmount) / g.Count() : 0
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }

                return Ok(trends);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving revenue trends");
                return StatusCode(500, new { message = "An error occurred while retrieving revenue trends" });
            }
        }

        #endregion

        #region Order Analytics

        [HttpGet("orders/summary")]
        [ProducesResponseType(typeof(OrderSummaryDto), StatusCodes.Status200OK)]
        public async Task<ActionResult<OrderSummaryDto>> GetOrderSummary(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var query = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(o => o.CreatedAt <= toDate.Value);

                var orders = await query.ToListAsync();

                return Ok(new OrderSummaryDto
                {
                    TotalOrders = orders.Count,
                    PendingOrders = orders.Count(o => o.Status == "pending"),
                    PaidOrders = orders.Count(o => o.Status == "paid"),
                    ShippedOrders = orders.Count(o => o.Status == "shipped"),
                    DeliveredOrders = orders.Count(o => o.Status == "delivered"),
                    CancelledOrders = orders.Count(o => o.Status == "cancelled"),
                    AverageOrderValue = orders.Count > 0 ? orders.Sum(o => o.TotalAmount) / orders.Count : 0,
                    TotalOrderValue = orders.Sum(o => o.TotalAmount)
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving order summary");
                return StatusCode(500, new { message = "An error occurred while retrieving order summary" });
            }
        }

        [HttpGet("orders/status-breakdown")]
        [ProducesResponseType(typeof(List<OrderStatusBreakdownDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<OrderStatusBreakdownDto>>> GetOrderStatusBreakdown(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var query = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(o => o.CreatedAt <= toDate.Value);

                var orders = await query.ToListAsync();
                var totalOrders = orders.Count;

                var breakdown = orders
                    .GroupBy(o => o.Status)
                    .Select(g => new OrderStatusBreakdownDto
                    {
                        Status = g.Key,
                        Count = g.Count(),
                        Percentage = totalOrders > 0 ? (g.Count() * 100m) / totalOrders : 0,
                        TotalAmount = g.Sum(o => o.TotalAmount)
                    })
                    .OrderByDescending(x => x.Count)
                    .ToList();

                return Ok(breakdown);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving order status breakdown");
                return StatusCode(500, new { message = "An error occurred while retrieving order status breakdown" });
            }
        }

        [HttpGet("orders/conversion-funnel")]
        [ProducesResponseType(typeof(List<OrderConversionFunnelDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<OrderConversionFunnelDto>>> GetOrderConversionFunnel(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var query = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(o => o.CreatedAt <= toDate.Value);

                var orders = await query.ToListAsync();
                var totalOrders = (decimal)orders.Count;

                var stages = new[]
                {
                    new { Stage = "Pending", StatusFilter = new[] { "pending", "paid", "shipped", "delivered", "cancelled" } },
                    new { Stage = "Paid", StatusFilter = new[] { "paid", "shipped", "delivered" } },
                    new { Stage = "Shipped", StatusFilter = new[] { "shipped", "delivered" } },
                    new { Stage = "Delivered", StatusFilter = new[] { "delivered" } }
                };

                var funnel = stages.Select((stage, index) =>
                {
                    var count = orders.Count(o => stage.StatusFilter.Contains(o.Status));
                    var prevCount = index > 0 ? orders.Count(o => stages[index - 1].StatusFilter.Contains(o.Status)) : totalOrders;

                    return new OrderConversionFunnelDto
                    {
                        Stage = stage.Stage,
                        Count = count,
                        Percentage = totalOrders > 0 ? (count * 100m) / totalOrders : 0,
                        ConversionRateFromPrevious = prevCount > 0 ? (count * 100m) / prevCount : 0
                    };
                }).ToList();

                return Ok(funnel);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving order conversion funnel");
                return StatusCode(500, new { message = "An error occurred while retrieving order conversion funnel" });
            }
        }

        [HttpGet("orders/cancellation-metrics")]
        [ProducesResponseType(typeof(OrderCancellationMetricsDto), StatusCodes.Status200OK)]
        public async Task<ActionResult<OrderCancellationMetricsDto>> GetOrderCancellationMetrics()
        {
            try
            {
                var allOrders = await _context.Orders.ToListAsync();
                var cancellations = allOrders.Where(o => o.Status == "cancelled").ToList();
                var now = DateTime.UtcNow;

                var metrics = new OrderCancellationMetricsDto
                {
                    TotalCancellations = cancellations.Count,
                    CancellationRate = allOrders.Count > 0 ? (cancellations.Count * 100m) / allOrders.Count : 0,
                    CancelledAmount = cancellations.Sum(o => o.TotalAmount),
                    CancellationsToday = cancellations.Count(o => o.CreatedAt.Date == now.Date),
                    CancellationsThisWeek = cancellations.Count(o => o.CreatedAt >= GetWeekStart(now)),
                    CancellationsThisMonth = cancellations.Count(o => o.CreatedAt.Month == now.Month && o.CreatedAt.Year == now.Year)
                };

                return Ok(metrics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving order cancellation metrics");
                return StatusCode(500, new { message = "An error occurred while retrieving order cancellation metrics" });
            }
        }

        [HttpGet("orders/geographic")]
        [ProducesResponseType(typeof(List<GeographicOrderMetricsDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<GeographicOrderMetricsDto>>> GetGeographicOrderMetrics(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var query = _context.Orders.Include(o => o.Address).AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(o => o.CreatedAt <= toDate.Value);

                var metrics = await query
                    .GroupBy(o => new { o.Address.City, o.Address.Country })
                    .Select(g => new GeographicOrderMetricsDto
                    {
                        City = g.Key.City,
                        Country = g.Key.Country,
                        OrderCount = g.Count(),
                        TotalAmount = g.Sum(o => o.TotalAmount),
                        AverageOrderValue = g.Count() > 0 ? g.Sum(o => o.TotalAmount) / g.Count() : 0
                    })
                    .OrderByDescending(x => x.TotalAmount)
                    .ToListAsync();

                return Ok(metrics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving geographic order metrics");
                return StatusCode(500, new { message = "An error occurred while retrieving geographic order metrics" });
            }
        }

        [HttpGet("orders/trends")]
        [ProducesResponseType(typeof(List<OrderTrendDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<OrderTrendDto>>> GetOrderTrends(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate,
            [FromQuery] string period = "daily") // daily, weekly, monthly
        {
            try
            {
                var query = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(o => o.CreatedAt <= toDate.Value);

                var orders = await query.ToListAsync();

                List<OrderTrendDto> trends;

                if (period.ToLower() == "daily")
                {
                    trends = orders
                        .GroupBy(o => o.CreatedAt.Date)
                        .Select(g => new OrderTrendDto
                        {
                            Date = g.Key,
                            OrderCount = g.Count(),
                            TotalAmount = g.Sum(o => o.TotalAmount)
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }
                else if (period.ToLower() == "weekly")
                {
                    trends = orders
                        .GroupBy(o => GetWeekStart(o.CreatedAt))
                        .Select(g => new OrderTrendDto
                        {
                            Date = g.Key,
                            OrderCount = g.Count(),
                            TotalAmount = g.Sum(o => o.TotalAmount)
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }
                else // monthly
                {
                    trends = orders
                        .GroupBy(o => new DateTime(o.CreatedAt.Year, o.CreatedAt.Month, 1))
                        .Select(g => new OrderTrendDto
                        {
                            Date = g.Key,
                            OrderCount = g.Count(),
                            TotalAmount = g.Sum(o => o.TotalAmount)
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }

                return Ok(trends);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving order trends");
                return StatusCode(500, new { message = "An error occurred while retrieving order trends" });
            }
        }

        #endregion

        #region Customer Analytics

        [HttpGet("customers/summary")]
        [ProducesResponseType(typeof(CustomerSummaryDto), StatusCodes.Status200OK)]
        public async Task<ActionResult<CustomerSummaryDto>> GetCustomerSummary()
        {
            try
            {
                var customers = await _context.Customers.ToListAsync();
                var orders = await _context.Orders.ToListAsync();
                var now = DateTime.UtcNow;

                var activeCustomers = customers
                    .Where(c => orders.Any(o => o.CustomerId == c.Id))
                    .ToList();

                var summary = new CustomerSummaryDto
                {
                    TotalCustomers = customers.Count,
                    WebsiteCustomers = customers.Count(c => c.IsFromWebsite),
                    AdminCreatedCustomers = customers.Count(c => !c.IsFromWebsite),
                    ActiveCustomers = activeCustomers.Count,
                    NewCustomersToday = customers.Count(c => c.CreatedAt.Date == now.Date),
                    NewCustomersThisWeek = customers.Count(c => c.CreatedAt >= GetWeekStart(now)),
                    NewCustomersThisMonth = customers.Count(c => c.CreatedAt.Month == now.Month && c.CreatedAt.Year == now.Year),
                    AverageCustomerValue = activeCustomers.Count > 0
                        ? orders.Where(o => activeCustomers.Select(c => c.Id).Contains(o.CustomerId)).Sum(o => o.TotalAmount) / activeCustomers.Count
                        : 0
                };

                return Ok(summary);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving customer summary");
                return StatusCode(500, new { message = "An error occurred while retrieving customer summary" });
            }
        }

        [HttpGet("customers/acquisition")]
        [ProducesResponseType(typeof(List<CustomerAcquisitionDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<CustomerAcquisitionDto>>> GetCustomerAcquisition(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate,
            [FromQuery] string period = "daily")
        {
            try
            {
                var query = _context.Customers.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(c => c.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(c => c.CreatedAt <= toDate.Value);

                var customers = await query.ToListAsync();

                List<CustomerAcquisitionDto> acquisition;

                if (period.ToLower() == "daily")
                {
                    acquisition = customers
                        .GroupBy(c => c.CreatedAt.Date)
                        .Select(g => new CustomerAcquisitionDto
                        {
                            Date = g.Key,
                            TotalNewCustomers = g.Count(),
                            WebsiteCustomers = g.Count(c => c.IsFromWebsite),
                            AdminCreatedCustomers = g.Count(c => !c.IsFromWebsite)
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }
                else if (period.ToLower() == "weekly")
                {
                    acquisition = customers
                        .GroupBy(c => GetWeekStart(c.CreatedAt))
                        .Select(g => new CustomerAcquisitionDto
                        {
                            Date = g.Key,
                            TotalNewCustomers = g.Count(),
                            WebsiteCustomers = g.Count(c => c.IsFromWebsite),
                            AdminCreatedCustomers = g.Count(c => !c.IsFromWebsite)
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }
                else // monthly
                {
                    acquisition = customers
                        .GroupBy(c => new DateTime(c.CreatedAt.Year, c.CreatedAt.Month, 1))
                        .Select(g => new CustomerAcquisitionDto
                        {
                            Date = g.Key,
                            TotalNewCustomers = g.Count(),
                            WebsiteCustomers = g.Count(c => c.IsFromWebsite),
                            AdminCreatedCustomers = g.Count(c => !c.IsFromWebsite)
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }

                return Ok(acquisition);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving customer acquisition");
                return StatusCode(500, new { message = "An error occurred while retrieving customer acquisition" });
            }
        }

        [HttpGet("customers/repeat")]
        [ProducesResponseType(typeof(RepeatCustomerMetricsDto), StatusCodes.Status200OK)]
        public async Task<ActionResult<RepeatCustomerMetricsDto>> GetRepeatCustomerMetrics()
        {
            try
            {
                var customers = await _context.Customers.ToListAsync();
                var orders = await _context.Orders.ToListAsync();

                var customerOrderCounts = customers
                    .Select(c => new
                    {
                        CustomerId = c.Id,
                        OrderCount = orders.Count(o => o.CustomerId == c.Id)
                    })
                    .ToList();

                var repeatCustomers = customerOrderCounts.Where(c => c.OrderCount > 1).ToList();
                var oneTimeCustomers = customerOrderCounts.Where(c => c.OrderCount == 1).ToList();

                var metrics = new RepeatCustomerMetricsDto
                {
                    TotalCustomers = customers.Count,
                    OneTimeCustomers = oneTimeCustomers.Count,
                    RepeatCustomers = repeatCustomers.Count,
                    RepeatCustomerRate = customers.Count > 0 ? (repeatCustomers.Count * 100m) / customers.Count : 0,
                    AverageOrdersPerRepeatCustomer = repeatCustomers.Count > 0
                        ? (decimal)repeatCustomers.Average(c => c.OrderCount)
                        : 0
                };

                return Ok(metrics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving repeat customer metrics");
                return StatusCode(500, new { message = "An error occurred while retrieving repeat customer metrics" });
            }
        }

        [HttpGet("customers/lifetime-value")]
        [ProducesResponseType(typeof(List<CustomerLifetimeValueDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<CustomerLifetimeValueDto>>> GetCustomerLifetimeValue(
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 50)
        {
            try
            {
                var customers = await _context.Customers
                    .Include(c => c.Orders)
                    .Skip((pageNumber - 1) * pageSize)
                    .Take(pageSize)
                    .ToListAsync();

                var clv = customers.Select(c => new CustomerLifetimeValueDto
                {
                    CustomerId = c.Id,
                    CustomerName = c.FullName,
                    Email = c.Email,
                    TotalSpent = c.Orders.Sum(o => o.TotalAmount),
                    OrderCount = c.Orders.Count,
                    AverageOrderValue = c.Orders.Count > 0 ? c.Orders.Sum(o => o.TotalAmount) / c.Orders.Count : 0,
                    FirstOrderDate = c.Orders.OrderBy(o => o.CreatedAt).FirstOrDefault()?.CreatedAt,
                    LastOrderDate = c.Orders.OrderByDescending(o => o.CreatedAt).FirstOrDefault()?.CreatedAt
                })
                .OrderByDescending(x => x.TotalSpent)
                .ToList();

                return Ok(clv);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving customer lifetime value");
                return StatusCode(500, new { message = "An error occurred while retrieving customer lifetime value" });
            }
        }

        [HttpGet("customers/geographic")]
        [ProducesResponseType(typeof(List<GeographicCustomerMetricsDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<GeographicCustomerMetricsDto>>> GetGeographicCustomerMetrics()
        {
            try
            {
                var metrics = await _context.Customers
                    .Include(c => c.Orders)
                    .Include(c => c.Addresses)
                    .SelectMany(c => c.Addresses.Select(a => new
                    {
                        City = a.City,
                        Country = a.Country,
                        CustomerId = c.Id,
                        Orders = c.Orders
                    }))
                    .GroupBy(x => new { x.City, x.Country })
                    .Select(g => new GeographicCustomerMetricsDto
                    {
                        City = g.Key.City,
                        Country = g.Key.Country,
                        CustomerCount = g.Select(x => x.CustomerId).Distinct().Count(),
                        TotalSpent = g.SelectMany(x => x.Orders).Sum(o => o.TotalAmount),
                        AverageCustomerValue = g.Select(x => x.CustomerId).Distinct().Count() > 0
                            ? g.SelectMany(x => x.Orders).Sum(o => o.TotalAmount) / g.Select(x => x.CustomerId).Distinct().Count()
                            : 0
                    })
                    .OrderByDescending(x => x.TotalSpent)
                    .ToListAsync();

                return Ok(metrics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving geographic customer metrics");
                return StatusCode(500, new { message = "An error occurred while retrieving geographic customer metrics" });
            }
        }

        [HttpGet("customers/source")]
        [ProducesResponseType(typeof(List<CustomerSourceMetricsDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<CustomerSourceMetricsDto>>> GetCustomerSourceMetrics()
        {
            try
            {
                var customers = await _context.Customers
                    .Include(c => c.Orders)
                    .ToListAsync();

                var totalCustomers = customers.Count;

                var metrics = new List<CustomerSourceMetricsDto>
                {
                    new()
                    {
                        Source = "website",
                        CustomerCount = customers.Count(c => c.IsFromWebsite),
                        TotalSpent = customers.Where(c => c.IsFromWebsite).SelectMany(c => c.Orders).Sum(o => o.TotalAmount)
                    },
                    new()
                    {
                        Source = "admin",
                        CustomerCount = customers.Count(c => !c.IsFromWebsite),
                        TotalSpent = customers.Where(c => !c.IsFromWebsite).SelectMany(c => c.Orders).Sum(o => o.TotalAmount)
                    }
                };

                var totalSpent = metrics.Sum(m => m.TotalSpent);

                foreach (var metric in metrics)
                {
                    metric.Percentage = totalCustomers > 0 ? (metric.CustomerCount * 100m) / totalCustomers : 0;
                    metric.AverageValue = metric.CustomerCount > 0 ? metric.TotalSpent / metric.CustomerCount : 0;
                }

                return Ok(metrics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving customer source metrics");
                return StatusCode(500, new { message = "An error occurred while retrieving customer source metrics" });
            }
        }

        #endregion

        #region Product Analytics

        [HttpGet("products/performance")]
        [ProducesResponseType(typeof(List<ProductPerformanceDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<ProductPerformanceDto>>> GetProductPerformance(
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 50,
            [FromQuery] DateTime? fromDate = null,
            [FromQuery] DateTime? toDate = null)
        {
            try
            {
                var ordersQuery = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    ordersQuery = ordersQuery.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    ordersQuery = ordersQuery.Where(o => o.CreatedAt <= toDate.Value);

                var orders = await ordersQuery.ToListAsync();

                var productPerformance = await _context.Products
                    .Include(p => p.Reviews)
                    .Skip((pageNumber - 1) * pageSize)
                    .Take(pageSize)
                    .Select(p => new ProductPerformanceDto
                    {
                        ProductId = p.Id,
                        ProductName = p.Name,
                        Category = p.Category != null ? p.Category.Name : "Unknown",
                        Vendor = p.Vendor != null ? p.Vendor.Name : "Unknown",
                        UnitsSold = p.Variants.SelectMany(v => orders.SelectMany(o => o.Items.Where(oi => oi.VariantId == v.Id))).Count(),
                        TotalRevenue = p.Variants.SelectMany(v => orders.SelectMany(o => o.Items.Where(oi => oi.VariantId == v.Id).Select(oi => oi.Price * oi.Quantity))).Sum(),
                        AveragePrice = p.Variants.Count > 0 ? (decimal)p.Variants.Average(v => (double)v.Price) : 0,
                        AverageRating = p.Reviews.Count > 0 ? (decimal)p.Reviews.Average(r => r.Rating) : 0,
                        ReviewCount = p.Reviews.Count
                    })
                    .OrderByDescending(x => x.TotalRevenue)
                    .ToListAsync();

                return Ok(productPerformance);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving product performance");
                return StatusCode(500, new { message = "An error occurred while retrieving product performance" });
            }
        }

        [HttpGet("categories/sales")]
        [ProducesResponseType(typeof(List<CategorySalesMetricsDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<CategorySalesMetricsDto>>> GetCategorySalesMetrics(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var ordersQuery = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    ordersQuery = ordersQuery.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    ordersQuery = ordersQuery.Where(o => o.CreatedAt <= toDate.Value);

                var orders = await ordersQuery.ToListAsync();
                var totalRevenue = orders.Sum(o => o.TotalAmount);

                var metrics = await _context.Categories
                    .Include(c => c.Products)
                    .ThenInclude(p => p.Variants)
                    .Select(c => new
                    {
                        CategoryId = c.Id,
                        CategoryName = c.Name,
                        ProductCount = c.Products.Count,
                        Items = c.Products.SelectMany(p => p.Variants)
                            .SelectMany(v => orders.SelectMany(o => o.Items.Where(oi => oi.VariantId == v.Id)))
                    })
                    .ToListAsync();

                var categorySales = metrics.Select(m => new CategorySalesMetricsDto
                {
                    CategoryId = m.CategoryId,
                    CategoryName = m.CategoryName,
                    ProductCount = m.ProductCount,
                    UnitsSold = m.Items.Count(),
                    TotalRevenue = m.Items.Sum(i => i.Price * i.Quantity),
                    Percentage = totalRevenue > 0 ? (m.Items.Sum(i => i.Price * i.Quantity) * 100m) / totalRevenue : 0
                })
                .OrderByDescending(x => x.TotalRevenue)
                .ToList();

                return Ok(categorySales);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving category sales metrics");
                return StatusCode(500, new { message = "An error occurred while retrieving category sales metrics" });
            }
        }

        [HttpGet("inventory/levels")]
        [ProducesResponseType(typeof(List<InventoryMetricsDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<InventoryMetricsDto>>> GetInventoryLevels(
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 50)
        {
            try
            {
                var thirtyDaysAgo = DateTime.UtcNow.AddDays(-30);
                var orders = await _context.Orders.Where(o => o.CreatedAt >= thirtyDaysAgo).ToListAsync();

                var metrics = await _context.ProductVariants
                    .Include(v => v.Product)
                    .Include(v => v.InventoryLogs)
                    .Skip((pageNumber - 1) * pageSize)
                    .Take(pageSize)
                    .Select(v => new
                    {
                        Variant = v,
                        RecentSales = orders.SelectMany(o => o.Items.Where(oi => oi.VariantId == v.Id)).Count(),
                        SalesValue = orders.SelectMany(o => o.Items.Where(oi => oi.VariantId == v.Id)).Sum(oi => oi.Price * oi.Quantity)
                    })
                    .ToListAsync();

                var inventoryMetrics = metrics.Select(m => new InventoryMetricsDto
                {
                    VariantId = m.Variant.Id,
                    Sku = m.Variant.Sku,
                    ProductName = m.Variant.Product?.Name ?? "Unknown",
                    CurrentStock = m.Variant.Stock,
                    Price = m.Variant.Price,
                    StockValue = m.Variant.Stock * m.Variant.Price,
                    RecentSales = m.RecentSales,
                    TurnoverRate = m.Variant.Stock > 0 ? m.RecentSales / (decimal)m.Variant.Stock : 0,
                    StockStatus = m.Variant.Stock < 10 ? "Low" : m.Variant.Stock > 100 ? "Excess" : "Optimal"
                })
                .OrderBy(x => x.CurrentStock)
                .ToList();

                return Ok(inventoryMetrics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving inventory levels");
                return StatusCode(500, new { message = "An error occurred while retrieving inventory levels" });
            }
        }

        [HttpGet("inventory/low-stock")]
        [ProducesResponseType(typeof(List<LowStockAlertDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<LowStockAlertDto>>> GetLowStockAlerts(
            [FromQuery] int threshold = 10)
        {
            try
            {
                var thirtyDaysAgo = DateTime.UtcNow.AddDays(-30);
                var orders = await _context.Orders.Where(o => o.CreatedAt >= thirtyDaysAgo).ToListAsync();

                var alerts = await _context.ProductVariants
                    .Include(v => v.Product)
                    .Where(v => v.Stock <= threshold)
                    .Select(v => new
                    {
                        Variant = v,
                        RecentSalesCount = orders.SelectMany(o => o.Items.Where(oi => oi.VariantId == v.Id)).Count()
                    })
                    .ToListAsync();

                var alertList = alerts.Select(a => new LowStockAlertDto
                {
                    VariantId = a.Variant.Id,
                    Sku = a.Variant.Sku,
                    ProductName = a.Variant.Product?.Name ?? "Unknown",
                    CurrentStock = a.Variant.Stock,
                    RecentSalesPerDay = a.RecentSalesCount / 30,
                    DaysUntilStockout = a.RecentSalesCount / 30 > 0 ? a.Variant.Stock / (a.RecentSalesCount / 30) : int.MaxValue
                })
                .OrderBy(x => x.DaysUntilStockout)
                .ToList();

                return Ok(alertList);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving low stock alerts");
                return StatusCode(500, new { message = "An error occurred while retrieving low stock alerts" });
            }
        }

        [HttpGet("vendors/performance")]
        [ProducesResponseType(typeof(List<VendorPerformanceDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<VendorPerformanceDto>>> GetVendorPerformance(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var ordersQuery = _context.Orders.AsQueryable();

                if (fromDate.HasValue)
                    ordersQuery = ordersQuery.Where(o => o.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    ordersQuery = ordersQuery.Where(o => o.CreatedAt <= toDate.Value);

                var orders = await ordersQuery.ToListAsync();
                var totalRevenue = orders.Sum(o => o.TotalAmount);

                var vendorMetrics = await _context.Vendors
                    .Include(v => v.Products)
                    .ThenInclude(p => p.Variants)
                    .ThenInclude(v => v.Product)
                    .ThenInclude(p => p.Reviews)
                    .Select(v => new
                    {
                        Vendor = v,
                        Items = v.Products.SelectMany(p => p.Variants)
                            .SelectMany(var => orders.SelectMany(o => o.Items.Where(oi => oi.VariantId == var.Id)))
                    })
                    .ToListAsync();

                var performance = vendorMetrics.Select(m => new VendorPerformanceDto
                {
                    VendorId = m.Vendor.Id,
                    VendorName = m.Vendor.Name,
                    ProductCount = m.Vendor.Products.Count,
                    TotalRevenue = m.Items.Sum(i => i.Price * i.Quantity),
                    TotalOrders = m.Items.Select(i => i.OrderId).Distinct().Count(),
                    AverageRating = m.Vendor.Products.SelectMany(p => p.Reviews).Count() > 0
                        ? (decimal)m.Vendor.Products.SelectMany(p => p.Reviews).Average(r => r.Rating)
                        : 0,
                    RevenuePercentage = totalRevenue > 0 ? (m.Items.Sum(i => i.Price * i.Quantity) * 100m) / totalRevenue : 0
                })
                .OrderByDescending(x => x.TotalRevenue)
                .ToList();

                return Ok(performance);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving vendor performance");
                return StatusCode(500, new { message = "An error occurred while retrieving vendor performance" });
            }
        }

        #endregion

        #region Payment Analytics

        [HttpGet("payments/summary")]
        [ProducesResponseType(typeof(PaymentSummaryDto), StatusCodes.Status200OK)]
        public async Task<ActionResult<PaymentSummaryDto>> GetPaymentSummary(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var query = _context.Payments.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(p => p.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(p => p.CreatedAt <= toDate.Value);

                var payments = await query.ToListAsync();

                var completed = payments.Where(p => p.Status == "completed").ToList();
                var failed = payments.Where(p => p.Status == "failed").ToList();

                var summary = new PaymentSummaryDto
                {
                    TotalPayments = payments.Count,
                    CompletedPayments = completed.Count,
                    PendingPayments = payments.Count(p => p.Status == "pending"),
                    FailedPayments = failed.Count,
                    RefundedPayments = payments.Count(p => p.Status == "refunded"),
                    TotalProcessed = completed.Sum(p => p.Amount),
                    SuccessRate = payments.Count > 0 ? (completed.Count * 100m) / payments.Count : 0,
                    FailureRate = payments.Count > 0 ? (failed.Count * 100m) / payments.Count : 0
                };

                return Ok(summary);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving payment summary");
                return StatusCode(500, new { message = "An error occurred while retrieving payment summary" });
            }
        }

        [HttpGet("payments/by-method")]
        [ProducesResponseType(typeof(List<PaymentMethodBreakdownDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<PaymentMethodBreakdownDto>>> GetPaymentsByMethod(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate)
        {
            try
            {
                var query = _context.Payments.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(p => p.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(p => p.CreatedAt <= toDate.Value);

                var payments = await query.ToListAsync();
                var totalAmount = payments.Sum(p => p.Amount);

                var breakdown = payments
                    .GroupBy(p => p.Method)
                    .Select(g => new
                    {
                        Method = g.Key,
                        Transactions = g.ToList()
                    })
                    .Select(g => new PaymentMethodBreakdownDto
                    {
                        PaymentMethod = g.Method,
                        TransactionCount = g.Transactions.Count,
                        TotalAmount = g.Transactions.Sum(p => p.Amount),
                        Percentage = totalAmount > 0 ? (g.Transactions.Sum(p => p.Amount) * 100m) / totalAmount : 0,
                        SuccessRate = g.Transactions.Count > 0
                            ? (g.Transactions.Count(p => p.Status == "completed") * 100m) / g.Transactions.Count
                            : 0
                    })
                    .OrderByDescending(x => x.TotalAmount)
                    .ToList();

                return Ok(breakdown);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving payments by method");
                return StatusCode(500, new { message = "An error occurred while retrieving payments by method" });
            }
        }

        [HttpGet("payments/refund-metrics")]
        [ProducesResponseType(typeof(RefundMetricsDto), StatusCodes.Status200OK)]
        public async Task<ActionResult<RefundMetricsDto>> GetRefundMetrics()
        {
            try
            {
                var allPayments = await _context.Payments.ToListAsync();
                var refunds = allPayments.Where(p => p.Status == "refunded").ToList();
                var now = DateTime.UtcNow;

                var metrics = new RefundMetricsDto
                {
                    TotalRefunds = refunds.Count,
                    TotalRefundedAmount = refunds.Sum(p => p.Amount),
                    RefundRate = allPayments.Count > 0 ? (refunds.Count * 100m) / allPayments.Count : 0,
                    AverageRefundAmount = refunds.Count > 0 ? refunds.Sum(p => p.Amount) / refunds.Count : 0,
                    RefundsToday = refunds.Count(p => p.CreatedAt.Date == now.Date),
                    RefundsThisWeek = refunds.Count(p => p.CreatedAt >= GetWeekStart(now)),
                    RefundsThisMonth = refunds.Count(p => p.CreatedAt.Month == now.Month && p.CreatedAt.Year == now.Year)
                };

                return Ok(metrics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving refund metrics");
                return StatusCode(500, new { message = "An error occurred while retrieving refund metrics" });
            }
        }

        [HttpGet("payments/trends")]
        [ProducesResponseType(typeof(List<PaymentTrendDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<PaymentTrendDto>>> GetPaymentTrends(
            [FromQuery] DateTime? fromDate,
            [FromQuery] DateTime? toDate,
            [FromQuery] string period = "daily")
        {
            try
            {
                var query = _context.Payments.AsQueryable();

                if (fromDate.HasValue)
                    query = query.Where(p => p.CreatedAt >= fromDate.Value);

                if (toDate.HasValue)
                    query = query.Where(p => p.CreatedAt <= toDate.Value);

                var payments = await query.ToListAsync();

                List<PaymentTrendDto> trends;

                if (period.ToLower() == "daily")
                {
                    trends = payments
                        .GroupBy(p => p.CreatedAt.Date)
                        .Select(g => new PaymentTrendDto
                        {
                            Date = g.Key,
                            CompletedAmount = g.Where(p => p.Status == "completed").Sum(p => p.Amount),
                            CompletedCount = g.Count(p => p.Status == "completed"),
                            FailedAmount = g.Where(p => p.Status == "failed").Sum(p => p.Amount),
                            FailedCount = g.Count(p => p.Status == "failed")
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }
                else if (period.ToLower() == "weekly")
                {
                    trends = payments
                        .GroupBy(p => GetWeekStart(p.CreatedAt))
                        .Select(g => new PaymentTrendDto
                        {
                            Date = g.Key,
                            CompletedAmount = g.Where(p => p.Status == "completed").Sum(p => p.Amount),
                            CompletedCount = g.Count(p => p.Status == "completed"),
                            FailedAmount = g.Where(p => p.Status == "failed").Sum(p => p.Amount),
                            FailedCount = g.Count(p => p.Status == "failed")
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }
                else // monthly
                {
                    trends = payments
                        .GroupBy(p => new DateTime(p.CreatedAt.Year, p.CreatedAt.Month, 1))
                        .Select(g => new PaymentTrendDto
                        {
                            Date = g.Key,
                            CompletedAmount = g.Where(p => p.Status == "completed").Sum(p => p.Amount),
                            CompletedCount = g.Count(p => p.Status == "completed"),
                            FailedAmount = g.Where(p => p.Status == "failed").Sum(p => p.Amount),
                            FailedCount = g.Count(p => p.Status == "failed")
                        })
                        .OrderBy(x => x.Date)
                        .ToList();
                }

                return Ok(trends);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving payment trends");
                return StatusCode(500, new { message = "An error occurred while retrieving payment trends" });
            }
        }

        #endregion

        #region Review Analytics

        [HttpGet("reviews/summary")]
        [ProducesResponseType(typeof(ReviewSummaryDto), StatusCodes.Status200OK)]
        public async Task<ActionResult<ReviewSummaryDto>> GetReviewSummary()
        {
            try
            {
                var reviews = await _context.Reviews.ToListAsync();
                var products = await _context.Products.ToListAsync();

                var productsWithReviews = reviews.Select(r => r.ProductId).Distinct().Count();
                var productsWithoutReviews = products.Count - productsWithReviews;

                var summary = new ReviewSummaryDto
                {
                    TotalReviews = reviews.Count,
                    AverageRating = reviews.Count > 0 ? (decimal)reviews.Average(r => r.Rating) : 0,
                    ProductsWithReviews = productsWithReviews,
                    ProductsWithoutReviews = productsWithoutReviews,
                    ReviewCoverage = products.Count > 0 ? (productsWithReviews * 100m) / products.Count : 0
                };

                return Ok(summary);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving review summary");
                return StatusCode(500, new { message = "An error occurred while retrieving review summary" });
            }
        }

        [HttpGet("reviews/rating-distribution")]
        [ProducesResponseType(typeof(List<RatingDistributionDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<RatingDistributionDto>>> GetRatingDistribution()
        {
            try
            {
                var reviews = await _context.Reviews.ToListAsync();
                var totalReviews = reviews.Count;

                var distribution = Enumerable.Range(1, 5)
                    .Select(stars => new RatingDistributionDto
                    {
                        Stars = stars,
                        Count = reviews.Count(r => r.Rating == stars),
                        Percentage = totalReviews > 0 ? (reviews.Count(r => r.Rating == stars) * 100m) / totalReviews : 0
                    })
                    .ToList();

                return Ok(distribution);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving rating distribution");
                return StatusCode(500, new { message = "An error occurred while retrieving rating distribution" });
            }
        }

        [HttpGet("reviews/product-ratings")]
        [ProducesResponseType(typeof(List<ProductRatingDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<ProductRatingDto>>> GetProductRatings(
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 50)
        {
            try
            {
                var productRatings = await _context.Products
                    .Include(p => p.Reviews)
                    .Skip((pageNumber - 1) * pageSize)
                    .Take(pageSize)
                    .Select(p => new ProductRatingDto
                    {
                        ProductId = p.Id,
                        ProductName = p.Name,
                        AverageRating = p.Reviews.Count > 0 ? (decimal)p.Reviews.Average(r => r.Rating) : 0,
                        ReviewCount = p.Reviews.Count,
                        OneStarCount = p.Reviews.Count(r => r.Rating == 1),
                        TwoStarCount = p.Reviews.Count(r => r.Rating == 2),
                        ThreeStarCount = p.Reviews.Count(r => r.Rating == 3),
                        FourStarCount = p.Reviews.Count(r => r.Rating == 4),
                        FiveStarCount = p.Reviews.Count(r => r.Rating == 5)
                    })
                    .OrderByDescending(x => x.AverageRating)
                    .ToListAsync();

                return Ok(productRatings);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving product ratings");
                return StatusCode(500, new { message = "An error occurred while retrieving product ratings" });
            }
        }

        [HttpGet("reviews/top-rated")]
        [ProducesResponseType(typeof(List<TopRatedProductsDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<TopRatedProductsDto>>> GetTopRatedProducts(
            [FromQuery] int limit = 10,
            [FromQuery] int minReviews = 1)
        {
            try
            {
                var topRated = await _context.Products
                    .Include(p => p.Reviews)
                    .Include(p => p.Category)
                    .Where(p => p.Reviews.Count >= minReviews)
                    .Select(p => new TopRatedProductsDto
                    {
                        ProductId = p.Id,
                        ProductName = p.Name,
                        Category = p.Category != null ? p.Category.Name : "Unknown",
                        AverageRating = p.Reviews.Count > 0 ? (decimal)p.Reviews.Average(r => r.Rating) : 0,
                        ReviewCount = p.Reviews.Count
                    })
                    .OrderByDescending(x => x.AverageRating)
                    .ThenByDescending(x => x.ReviewCount)
                    .Take(limit)
                    .ToListAsync();

                return Ok(topRated);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving top rated products");
                return StatusCode(500, new { message = "An error occurred while retrieving top rated products" });
            }
        }

        [HttpGet("reviews/low-rated")]
        [ProducesResponseType(typeof(List<LowRatedProductsDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<List<LowRatedProductsDto>>> GetLowRatedProducts(
            [FromQuery] int limit = 10,
            [FromQuery] int minReviews = 1)
        {
            try
            {
                var lowRated = await _context.Products
                    .Include(p => p.Reviews)
                    .Include(p => p.Category)
                    .Where(p => p.Reviews.Count >= minReviews)
                    .Select(p => new LowRatedProductsDto
                    {
                        ProductId = p.Id,
                        ProductName = p.Name,
                        Category = p.Category != null ? p.Category.Name : "Unknown",
                        AverageRating = p.Reviews.Count > 0 ? (decimal)p.Reviews.Average(r => r.Rating) : 0,
                        ReviewCount = p.Reviews.Count
                    })
                    .OrderBy(x => x.AverageRating)
                    .ThenByDescending(x => x.ReviewCount)
                    .Take(limit)
                    .ToListAsync();

                return Ok(lowRated);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving low rated products");
                return StatusCode(500, new { message = "An error occurred while retrieving low rated products" });
            }
        }

        #endregion

        #region Helper Methods

        private DateTime GetWeekStart(DateTime date)
        {
            var diff = (int)date.DayOfWeek - (int)DayOfWeek.Monday;
            if (diff < 0)
                diff += 7;
            return date.AddDays(-diff).Date;
        }

        #endregion
    }
}
